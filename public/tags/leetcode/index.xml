<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Leetcode on Denis Razsolkov</title>
    <link>http://localhost:1313/tags/leetcode/</link>
    <description>Recent content in Leetcode on Denis Razsolkov</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 04 Apr 2025 11:58:54 +0200</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>572. Subtree Of Another Tree - LeetCode</title>
      <link>http://localhost:1313/posts/572.subtreeofanothertree/</link>
      <pubDate>Fri, 04 Apr 2025 11:58:54 +0200</pubDate>
      <guid>http://localhost:1313/posts/572.subtreeofanothertree/</guid>
      <description>Problem Description Given the roots of two binary trees root and subRoot, return True if there is a subtree of root with the same structure and node values of subRoot and False otherwise.&#xA;A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node&amp;rsquo;s descendants. The tree tree could also be considered as a subtree of itself.&#xA;Example 1: Input: root = [3,4,5,1,2], subRoot = [4,1,2] Output: True Example 2: Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] Output: False My Idea My idea here was to utilize the isSameTree(p,q) function from 100.</description>
    </item>
    <item>
      <title>100. Same Tree - LeetCode</title>
      <link>http://localhost:1313/posts/100.sametree/</link>
      <pubDate>Fri, 04 Apr 2025 10:39:54 +0200</pubDate>
      <guid>http://localhost:1313/posts/100.sametree/</guid>
      <description>Problem Description Given the roots of two binary trees p and q, write a function to check if they are the same or not.&#xA;Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.&#xA;Example 1: Input: p = [1,2,3], q = [1,2,3] Output: True Example 2: Input: p = [1,2], q = [1,null,2] Output: False Example 3: Input: p = [1,2,1], q = [1,1,2] Output: False My Idea My idea here was to modify the algorithm from 104.</description>
    </item>
    <item>
      <title>110. Balanced Binary Tree - LeetCode</title>
      <link>http://localhost:1313/posts/110.balancedbinarytree/</link>
      <pubDate>Thu, 03 Apr 2025 14:58:22 +0200</pubDate>
      <guid>http://localhost:1313/posts/110.balancedbinarytree/</guid>
      <description>Problem Description Given a binary tree, determine if it is height-balanced.&#xA;A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.&#xA;Example 1: Input: root = [3,9,20,null,null,15,7] Output: True Example 2: Input: root = [1,2,2,3,3,null,null,4,4] Output: False Example 3: Input: root = [] Output: True My Idea The idea here is very similar to the one in 543.</description>
    </item>
    <item>
      <title>543. Diameter Of Binary Tree - LeetCode</title>
      <link>http://localhost:1313/posts/543.diameterofbinarytree/</link>
      <pubDate>Thu, 03 Apr 2025 14:33:20 +0200</pubDate>
      <guid>http://localhost:1313/posts/543.diameterofbinarytree/</guid>
      <description>Problem Description Given the root of a binary tree, return the length of the diameter of the tree.&#xA;The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.&#xA;The length of a path between two nodes is represented by the number of edges between them.&#xA;Example 1: Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    <item>
      <title>104. Maximum Depth Of Binary Tree - LeetCode</title>
      <link>http://localhost:1313/posts/104.maximumdepthofbinarytree/</link>
      <pubDate>Thu, 03 Apr 2025 11:18:59 +0200</pubDate>
      <guid>http://localhost:1313/posts/104.maximumdepthofbinarytree/</guid>
      <description>Problem Description Given the root of a binary tree, return its maximum depth.&#xA;A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&#xA;Example 1: Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2: Input: root = [1,null,2] Output: 2 My Idea My idea here was to utilize recursion and DFS. If the root has no children return 1, else return 1 plus the max from the depths of its children.</description>
    </item>
    <item>
      <title>226. Invert Binary Tree - LeetCode</title>
      <link>http://localhost:1313/posts/226.invertbinarytree/</link>
      <pubDate>Thu, 03 Apr 2025 11:01:35 +0200</pubDate>
      <guid>http://localhost:1313/posts/226.invertbinarytree/</guid>
      <description>Problem Description Given the root of a binary tree, invert the tree, and return its root.&#xA;Example 1: Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] Example 2: Input: root = [2,1,3] Output: [2,3,1] My Idea My idea here was to use recursion and DFS. If the root has no children return root, else swap the left and the right children and invert them.&#xA;My solution from typing import Optional # Definition for a binary tree node.</description>
    </item>
    <item>
      <title>25. Reverse Nodes In K-Group - Leet Code</title>
      <link>http://localhost:1313/posts/25.reversenodesinkgroup/</link>
      <pubDate>Thu, 03 Apr 2025 10:20:15 +0200</pubDate>
      <guid>http://localhost:1313/posts/25.reversenodesinkgroup/</guid>
      <description>Problem Description Given the head of a linked list, reverse the nodes of the list k at a time, and return the modified list.&#xA;k is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of k then left-out nodes, in the end, should remain as it is.&#xA;You may not alter the values in the list&amp;rsquo;s nodes, only nodes themselves may be changed.</description>
    </item>
    <item>
      <title>23. Merge K Sorted Lists - LeetCode</title>
      <link>http://localhost:1313/posts/23.mergeksortedlists/</link>
      <pubDate>Tue, 01 Apr 2025 11:28:31 +0200</pubDate>
      <guid>http://localhost:1313/posts/23.mergeksortedlists/</guid>
      <description>Problem Description You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.&#xA;Merge all the linked-lists into one sorted linked-list and return it.&#xA;Example 1: Input: lists = [[1,4,5],[1,3,4],[2,6]] Output: [1,1,2,3,4,4,5,6] Example 2: Input: [] Output: [] My Idea My initial idea was to simply iterate over the list and merge the elements one by one. This yielded a time complexity of O(n*k). To optimize this approach we can go ahead and merge the list in twos until we get one list.</description>
    </item>
    <item>
      <title>146. LRU Cache - LeetCode</title>
      <link>http://localhost:1313/posts/146.lrucache/</link>
      <pubDate>Fri, 28 Mar 2025 16:11:01 +0100</pubDate>
      <guid>http://localhost:1313/posts/146.lrucache/</guid>
      <description>Problem Description Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.&#xA;Implement the LRUCache class:&#xA;LRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.</description>
    </item>
    <item>
      <title>287. Find The Duplicate Number - LeetCode</title>
      <link>http://localhost:1313/posts/287.findtheduplicatenumber/</link>
      <pubDate>Fri, 28 Mar 2025 11:47:58 +0100</pubDate>
      <guid>http://localhost:1313/posts/287.findtheduplicatenumber/</guid>
      <description>Problem Description Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.&#xA;There is only one repeated number in nums, return this repeated number.&#xA;You must solve the problem without modifying the array nums and using only constant extra space.&#xA;Example 1: Input: nums = [1,3,4,2,2] Output: 2 Example 2: Input: nums = [3,1,3,4,2] Output: 3 My Idea The hard part here is figuring out that the array can be seen as a singly inked list, where the index is the value of the node and the value at this index is a pointer to the next node.</description>
    </item>
    <item>
      <title>2. Add Two Numbers - LeetCode</title>
      <link>http://localhost:1313/posts/2.addtwonumbers/</link>
      <pubDate>Fri, 28 Mar 2025 10:49:03 +0100</pubDate>
      <guid>http://localhost:1313/posts/2.addtwonumbers/</guid>
      <description>Problem Description You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.&#xA;You may assume the two numbers do not contain any leading zero, except the number 0 itself.&#xA;Example 1: Input: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Example 2: Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] My Idea The idea here was to store the result in a new list res.</description>
    </item>
    <item>
      <title>138. Copy List With Random Pointer - LeetCode</title>
      <link>http://localhost:1313/posts/138.copylistwithrandompointer/</link>
      <pubDate>Fri, 28 Mar 2025 10:48:48 +0100</pubDate>
      <guid>http://localhost:1313/posts/138.copylistwithrandompointer/</guid>
      <description>Problem Description A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.&#xA;Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state.</description>
    </item>
    <item>
      <title>19. Remove N-th Node From End Of List - LeetCode</title>
      <link>http://localhost:1313/posts/19.removenthnodefromendoflist/</link>
      <pubDate>Fri, 28 Mar 2025 10:47:42 +0100</pubDate>
      <guid>http://localhost:1313/posts/19.removenthnodefromendoflist/</guid>
      <description>Problem Description Given the head of a linked list, remove the n-th node from the end of the list and return its head.&#xA;Example 1: Input: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2: Input: head = [1,2], n = 1 Output: [1] My Idea The idea here is to use two pointer s and f. First we move f n+1 steps ahead of s, so that there is a n-node gap between s and f.</description>
    </item>
    <item>
      <title>143. Reorder List - LeetCode</title>
      <link>http://localhost:1313/posts/143.reorderlist/</link>
      <pubDate>Wed, 26 Mar 2025 20:31:09 +0100</pubDate>
      <guid>http://localhost:1313/posts/143.reorderlist/</guid>
      <description>Problem Description You are given the head of a singly linked-list. The list can be represented as:&#xA;$L_0 → L_1 → … → L_{(n - 1)} → L_n$&#xA;Reorder the list to be on the following form:&#xA;$L_0 → L_n → L_1 → L_{(n - 1)} → L_2 → L_{(n - 2)} → …$&#xA;You may not modify the values in the list&amp;rsquo;s nodes. Only nodes themselves may be changed.</description>
    </item>
    <item>
      <title>206. Reverse Linked List - LeetCode</title>
      <link>http://localhost:1313/posts/206.reverselinkedlist/</link>
      <pubDate>Wed, 26 Mar 2025 20:21:57 +0100</pubDate>
      <guid>http://localhost:1313/posts/206.reverselinkedlist/</guid>
      <description>Problem Description Given the head of a singly linked list, reverse the list, and return the reversed list.&#xA;Example 1: Input: head = [1,2,3,4,5] Output: [5,4,3,2,1] Example 2: Input: head = [1,2] Output: [2,1] My Idea The idea here is to traverse the linked list and for every element reverse the direction of the link.&#xA;My solution from typing import Optional # Definition for singly-linked list. class ListNode: def __init__(self, val=0, next=None): self.</description>
    </item>
    <item>
      <title>141. Linked List Cycle - LeetCode</title>
      <link>http://localhost:1313/posts/141.linkedlistcycle/</link>
      <pubDate>Wed, 26 Mar 2025 20:20:11 +0100</pubDate>
      <guid>http://localhost:1313/posts/141.linkedlistcycle/</guid>
      <description>Problem Description Given head, the head of a linked list, determine if the linked list has a cycle in it.&#xA;There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail&amp;rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.</description>
    </item>
    <item>
      <title>21. Merge Two Sorted Lists - LeetCode</title>
      <link>http://localhost:1313/posts/21.mergetwosortedlists/</link>
      <pubDate>Wed, 26 Mar 2025 20:17:02 +0100</pubDate>
      <guid>http://localhost:1313/posts/21.mergetwosortedlists/</guid>
      <description>Problem Description You are given the heads of two sorted linked lists list1 and list2.&#xA;Merge the two lists into one sorted list. The list should be made by splicing together the nodes of the first two lists.&#xA;Return the head of the merged linked list.&#xA;Example 1: Input: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2: Input: list1 = [], list2 = [0] Output: [0] My Idea The idea here is to check which element has a lower value and set it as the next one in the list.</description>
    </item>
    <item>
      <title>76. Minimum Window Substring - LeetCode</title>
      <link>http://localhost:1313/posts/76.minimumwindowsubstring/</link>
      <pubDate>Tue, 25 Mar 2025 16:46:05 +0100</pubDate>
      <guid>http://localhost:1313/posts/76.minimumwindowsubstring/</guid>
      <description>Problem Description Given two strings s and t of lengths m and n respectively, return the minimum window substring of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string &amp;quot;&amp;quot;.&#xA;The testcases will be generated such that the answer is unique.&#xA;Example 1: Input: s = &amp;quot;ADOBECODEBANC&amp;quot;, t = &amp;quot;ABC&amp;quot; Output: &amp;quot;BANC&amp;quot; Explanation: The minimum window substring &amp;quot;BANC&amp;quot; includes &#39;A&#39;, &#39;B&#39;, and &#39;C&#39; from string t.</description>
    </item>
    <item>
      <title>239. Sliding Window Maximum - LeetCode</title>
      <link>http://localhost:1313/posts/239.slidingwindowmaximum/</link>
      <pubDate>Tue, 25 Mar 2025 16:43:53 +0100</pubDate>
      <guid>http://localhost:1313/posts/239.slidingwindowmaximum/</guid>
      <description>Problem Description You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.&#xA;Return the max of the sliding window.&#xA;Example 1: Input: nums = [1,3,-1,-3,5,3,6,7], k = 3 Output: [3,3,5,5,6,7] Explanation: Window position Max --------------- ----- [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 Example 2: Input: nums = [1], k = 1 Output: [1] My Idea The initial idea was simply to check for the max element in each window and add it to the resulting list.</description>
    </item>
    <item>
      <title>567. Permutation In String - LeetCode</title>
      <link>http://localhost:1313/posts/567.permutationinstring/</link>
      <pubDate>Tue, 25 Mar 2025 16:42:34 +0100</pubDate>
      <guid>http://localhost:1313/posts/567.permutationinstring/</guid>
      <description>Problem Description Given two strings s1 and s2, return True if s2 contains a permutation of s1, or False otherwise.&#xA;In other words, return True if one of s1&#39;s permutations is the substring of s2.&#xA;Example 1: Input: s1 = &amp;quot;ab&amp;quot;, s2 = &amp;quot;eidbaooo&amp;quot; Output: True Explanation: s2 contains one permutation of s1 (&amp;quot;ba&amp;quot;). Example 2: Input: s1 = &amp;quot;ab&amp;quot;, s2 = &amp;quot;eidboaoo&amp;quot; Output: False My Idea The idea here was to set a window size of len(s1) and check the frequency hashmap of the characters in the window of s2 against the one for s1.</description>
    </item>
    <item>
      <title>424. Longest Repeating Character Replacement - LeetCode</title>
      <link>http://localhost:1313/posts/424.longestrepeatingcharacterreplacement/</link>
      <pubDate>Tue, 25 Mar 2025 16:40:25 +0100</pubDate>
      <guid>http://localhost:1313/posts/424.longestrepeatingcharacterreplacement/</guid>
      <description>Problem Description You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.&#xA;Return the length of the longest substring containing the same letter you can get after performing the above operations.&#xA;Example 1: Input: s = &amp;quot;ABAB&amp;quot;, k = 2 Output: 4 Explanation: Replace the two &#39;A&#39;s with two &#39;B&#39;s or vice versa.</description>
    </item>
    <item>
      <title>3. Longest Substring Without Repeating Character - Leet Code</title>
      <link>http://localhost:1313/posts/3.longestsubstringwithoutrepeatingcharacter/</link>
      <pubDate>Thu, 13 Mar 2025 12:58:41 +0100</pubDate>
      <guid>http://localhost:1313/posts/3.longestsubstringwithoutrepeatingcharacter/</guid>
      <description>Problem Description Given a string s, find the length of the longest substring without duplicate characters.&#xA;Example 1: Input: s = &amp;quot;abcabcbb&amp;quot; Output: 3 Example 2: Input: s = &amp;quot;pwwkew&amp;quot; Output: 3 My Idea The idea here is to utilize the Sliding Window approach. In every step we increase the window to the right. If we encounter a character that&amp;rsquo;s already a part of the current substring (window), we shorten from the left until the original instance is just outside of the window.</description>
    </item>
    <item>
      <title>121. Best Time to Buy and Sell Stock - LeetCode</title>
      <link>http://localhost:1313/posts/121.besttimetobuyandsellstock/</link>
      <pubDate>Thu, 06 Mar 2025 13:33:46 +0100</pubDate>
      <guid>http://localhost:1313/posts/121.besttimetobuyandsellstock/</guid>
      <description>Problem Description You are given an array prices where prices[i] is the price of a given stock on the i-th` day.&#xA;You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.&#xA;Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.&#xA;Example 1: Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    <item>
      <title>4. Median of Two Sorted Arrays - Leet Code</title>
      <link>http://localhost:1313/posts/4.medianoftwosortedarrays/</link>
      <pubDate>Wed, 05 Mar 2025 13:40:42 +0100</pubDate>
      <guid>http://localhost:1313/posts/4.medianoftwosortedarrays/</guid>
      <description>Problem Description Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.&#xA;The overall run time complexity should be O(log (m+n)).&#xA;Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.</description>
    </item>
    <item>
      <title>981. Time Based Key-Value Store - LeetCode</title>
      <link>http://localhost:1313/posts/981.timebasedkey-valuestore/</link>
      <pubDate>Wed, 05 Mar 2025 11:44:52 +0100</pubDate>
      <guid>http://localhost:1313/posts/981.timebasedkey-valuestore/</guid>
      <description>Problem Description Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key&amp;rsquo;s value at a certain timestamp.&#xA;Implement the TimeMap class:&#xA;TimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev &amp;lt;= timestamp.</description>
    </item>
    <item>
      <title>33. Search in Rotated Sorted Array - LeetCode</title>
      <link>http://localhost:1313/posts/33.searchrotatedsortedarray/</link>
      <pubDate>Fri, 28 Feb 2025 10:38:41 +0100</pubDate>
      <guid>http://localhost:1313/posts/33.searchrotatedsortedarray/</guid>
      <description>Problem Description There is an integer array nums sorted in ascending order (with distinct values).&#xA;Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].&#xA;Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description>
    </item>
    <item>
      <title>153. Finding Minimum in Rotated Sorted Array - LeetCode</title>
      <link>http://localhost:1313/posts/153.findingminimuminrotatedsortedarray/</link>
      <pubDate>Thu, 27 Feb 2025 14:36:46 +0100</pubDate>
      <guid>http://localhost:1313/posts/153.findingminimuminrotatedsortedarray/</guid>
      <description>Problem Description Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:&#xA;[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array numsof unique elements, return the minimum element of this array.</description>
    </item>
    <item>
      <title>875. Koko Eating Bananas - LeetCode</title>
      <link>http://localhost:1313/posts/875.kokoeatingbananas/</link>
      <pubDate>Wed, 26 Feb 2025 15:05:13 +0100</pubDate>
      <guid>http://localhost:1313/posts/875.kokoeatingbananas/</guid>
      <description>Problem Description Koko loves to eat bananas. There are n piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in h hours.&#xA;Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.</description>
    </item>
    <item>
      <title>74. Search a 2D Matrix - LeetCode</title>
      <link>http://localhost:1313/posts/74.search2dmatrix/</link>
      <pubDate>Wed, 26 Feb 2025 13:59:02 +0100</pubDate>
      <guid>http://localhost:1313/posts/74.search2dmatrix/</guid>
      <description>Problem Description You are given an m x n integer matrix matrix with the following two properties:&#xA;Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise.&#xA;You must write a solution in O(log(m * n)) time complexity.&#xA;Example 1: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: True Example 2: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output: False My Idea My idea here was to first utilize binary search on the first element of each row to find the possible row for target and then do one more binary search within this row to check if target is indeed there, thus yielding the desired time complexity of O(log m*n).</description>
    </item>
    <item>
      <title>704. Binary Search - LeetCode</title>
      <link>http://localhost:1313/posts/704.binarysearch/</link>
      <pubDate>Tue, 25 Feb 2025 15:18:49 +0100</pubDate>
      <guid>http://localhost:1313/posts/704.binarysearch/</guid>
      <description>Problem Description Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.&#xA;You must write an algorithm with O(log n) runtime complexity.&#xA;Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 My Idea The idea here is to implement the basic version of binary search, where we compare with the middle element and depending on weather it&amp;rsquo;s value is &amp;gt; or &amp;lt; than our target we restrict our problem space to the left or right half of the array respectively.</description>
    </item>
    <item>
      <title>42. Trapping Rain Water - LeetCode</title>
      <link>http://localhost:1313/posts/42.trappingrainwater/</link>
      <pubDate>Tue, 25 Feb 2025 14:01:44 +0100</pubDate>
      <guid>http://localhost:1313/posts/42.trappingrainwater/</guid>
      <description>Problem Description Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.&#xA;Example 1: Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 My Idea For each position in the resulting figure the amount of water that can be trapped is the minimum of the two highest peaks to the left and right minus the height at the position itself.</description>
    </item>
    <item>
      <title>15. 3Sum - Leet Code</title>
      <link>http://localhost:1313/posts/15.3sum/</link>
      <pubDate>Thu, 17 Oct 2024 14:42:11 +0200</pubDate>
      <guid>http://localhost:1313/posts/15.3sum/</guid>
      <description>Problem Description Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.&#xA;Notice that the solution set must not contain duplicate triplets.&#xA;Example 1: Input: nums = [-1,0,1,2,-1,-4]&#xA;Output: [[-1,-1,2],[-1,0,1]]&#xA;Explanation:&#xA;nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.&#xA;nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</description>
    </item>
    <item>
      <title>11. Container With Most Water - Leet Code</title>
      <link>http://localhost:1313/posts/11.containerwithmostwater/</link>
      <pubDate>Wed, 16 Oct 2024 11:15:06 +0200</pubDate>
      <guid>http://localhost:1313/posts/11.containerwithmostwater/</guid>
      <description>Problem Description You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the i-th line are (i, 0) and (i, height[i]).&#xA;Find two lines that together with the x-axis form a container, such that the container contains the most water.&#xA;Return the maximum amount of water a container can store.&#xA;Notice that you may not slant the container.</description>
    </item>
    <item>
      <title>167. Two Sum II - Input Array is sorted - Leet Code</title>
      <link>http://localhost:1313/posts/167.twosumii/</link>
      <pubDate>Wed, 09 Oct 2024 10:56:02 +0200</pubDate>
      <guid>http://localhost:1313/posts/167.twosumii/</guid>
      <description>Problem Description Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length.&#xA;Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.&#xA;The tests are generated such that there is exactly one solution.</description>
    </item>
    <item>
      <title>125. Valid Palindrome - Leet Code</title>
      <link>http://localhost:1313/posts/125.validpalindrome/</link>
      <pubDate>Tue, 08 Oct 2024 15:14:48 +0200</pubDate>
      <guid>http://localhost:1313/posts/125.validpalindrome/</guid>
      <description>Problem Description A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.&#xA;Given a string s, return true if it is a palindrome, or false otherwise.&#xA;Example 1: Input: s = &amp;quot;A man, a plan, a canal: Panama&amp;quot; Output: True Explanation: &amp;ldquo;amanaplanacanalpanama&amp;rdquo; is a palindrome. Example 2: Input: s = &amp;quot;race a car&amp;quot; Output: false Explanation: &amp;ldquo;raceacar&amp;rdquo; is not a palindrome.</description>
    </item>
    <item>
      <title>85. Longest Rectangle in Histogram - Leet Code</title>
      <link>http://localhost:1313/posts/85.longestrectangleinhistogram/</link>
      <pubDate>Tue, 08 Oct 2024 11:08:08 +0200</pubDate>
      <guid>http://localhost:1313/posts/85.longestrectangleinhistogram/</guid>
      <description>Problem Description Given an array of integers heights, representing the histogram&amp;rsquo;s bar height, where the width of each bar is 1, return the area of the largest rectangle in the histogram.&#xA;Example 1: Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. Example 2: Input: heights = [2,4] Output: 4 My Idea Here we once more make use of a stack to keep track of the bars.</description>
    </item>
    <item>
      <title>853. Car Fleet - Leet Code</title>
      <link>http://localhost:1313/posts/853.carfleet/</link>
      <pubDate>Wed, 02 Oct 2024 14:02:09 +0200</pubDate>
      <guid>http://localhost:1313/posts/853.carfleet/</guid>
      <description>Problem Description There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.&#xA;You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the i-th car and speed[i] is the speed of the i-th car in miles per hour.&#xA;A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.</description>
    </item>
    <item>
      <title>150. Evaluate Reverse Polish Notation - LeetCode</title>
      <link>http://localhost:1313/posts/150.evaluatereversepolishnotation/</link>
      <pubDate>Tue, 01 Oct 2024 10:59:31 +0200</pubDate>
      <guid>http://localhost:1313/posts/150.evaluatereversepolishnotation/</guid>
      <description>Problem Description You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.&#xA;Evaluate the expression. Return an integer that represents the value of the expression.&#xA;Note that:&#xA;The valid operators are &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, and &#39;/&#39;. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation.</description>
    </item>
    <item>
      <title>155. MinStack - LeetCode</title>
      <link>http://localhost:1313/posts/155.minstack/</link>
      <pubDate>Mon, 30 Sep 2024 10:46:12 +0200</pubDate>
      <guid>http://localhost:1313/posts/155.minstack/</guid>
      <description>Problem Description Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.&#xA;Implement the MinStack class:&#xA;MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. You must implement a solution with O(1) time complexity for each function.</description>
    </item>
    <item>
      <title>739. Daily Temperatures - LeetCode</title>
      <link>http://localhost:1313/posts/739.dailytemperatures/</link>
      <pubDate>Sun, 11 Aug 2024 18:42:48 +0200</pubDate>
      <guid>http://localhost:1313/posts/739.dailytemperatures/</guid>
      <description>Problem Description Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.&#xA;Example 1: Input: temperatures = [73,74,75,71,69,72,76,73] Output: [1,1,4,2,1,1,0,0] Example 2: Input: temperatures = [30,40,50,60] Output: [1,1,1,0] My Idea The idea here is to construct a stack of monotonically decreasing values.</description>
    </item>
    <item>
      <title>22. Generate Parentheses - LeetCode</title>
      <link>http://localhost:1313/posts/22.generateparentheses/</link>
      <pubDate>Fri, 09 Aug 2024 22:01:42 +0200</pubDate>
      <guid>http://localhost:1313/posts/22.generateparentheses/</guid>
      <description>Problem Description Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&#xA;Example 1: Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2: Input: n=1 Output: [&amp;quot;()&amp;quot;] My Idea The idea here is that as seen in 20. Valid Parentheses for the parentheses to be well-formed, we need the number of opening ones to match the number of closing ones. Since there are different possible combinations for the parentheses, we use recursion and backtracking.</description>
    </item>
    <item>
      <title>20. Valid Parentheses - LeetCode</title>
      <link>http://localhost:1313/posts/20.validparentheses/</link>
      <pubDate>Fri, 09 Aug 2024 21:23:04 +0200</pubDate>
      <guid>http://localhost:1313/posts/20.validparentheses/</guid>
      <description>Problem Description Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.&#xA;An input string is valid if:&#xA;Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.&#xA;Example 1: Input: s = &amp;quot;()&amp;quot; Output: True Example 2: Input: s = &amp;quot;()[]{}&amp;quot; Output: True Example 3: Input: s = &amp;quot;(]&amp;quot; Output: False My Idea The idea here is to use a list as a stack, taking advantage of the LIFO strategy.</description>
    </item>
    <item>
      <title>36. Valid Sudoku - LeetCode</title>
      <link>http://localhost:1313/posts/36.validsudoku/</link>
      <pubDate>Fri, 26 Jul 2024 11:24:00 +0200</pubDate>
      <guid>http://localhost:1313/posts/36.validsudoku/</guid>
      <description>Problem Description Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&#xA;Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note:&#xA;A Sudoku board (partially filled) could be valid but is not necessarily solvable.</description>
    </item>
    <item>
      <title>49. Group Anagrams - LeetCode</title>
      <link>http://localhost:1313/posts/49.groupanagrams/</link>
      <pubDate>Thu, 25 Jul 2024 15:10:27 +0200</pubDate>
      <guid>http://localhost:1313/posts/49.groupanagrams/</guid>
      <description>Problem Description Given an array of strings strs, group the anagrams together. You can return the answer in any order.&#xA;An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example 1: Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2: Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3: Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] My Idea My initial idea was to use the sorting approach from [[242.</description>
    </item>
    <item>
      <title>128. Longest Consecutive Sequence - LeetCode</title>
      <link>http://localhost:1313/posts/128.longestconsecutivesequence/</link>
      <pubDate>Thu, 25 Jul 2024 14:35:20 +0200</pubDate>
      <guid>http://localhost:1313/posts/128.longestconsecutivesequence/</guid>
      <description>Problem Description Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.&#xA;You must write an algorithm that runs in O(n) time.&#xA;Example 1: Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2: Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 My Idea To find the longest sequence in O(n) time, we&amp;rsquo;d need to optimize the data structure for nums by converting in to a set, since set lookup happens ins constant time O(1).</description>
    </item>
    <item>
      <title>238. Product of Array Except Self - LeetCode</title>
      <link>http://localhost:1313/posts/238.productofarrayexceptself/</link>
      <pubDate>Wed, 24 Jul 2024 11:20:28 +0200</pubDate>
      <guid>http://localhost:1313/posts/238.productofarrayexceptself/</guid>
      <description>Problem Description Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].&#xA;The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.&#xA;You must write an algorithm that runs in O(n) time and without using the division operation.&#xA;Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] My Idea My initial idea was to create the results list initiated with 1s.</description>
    </item>
    <item>
      <title>347. Top K Frequent Elements - LeetCode</title>
      <link>http://localhost:1313/posts/347.topkfrequentelements/</link>
      <pubDate>Tue, 23 Jul 2024 13:22:39 +0200</pubDate>
      <guid>http://localhost:1313/posts/347.topkfrequentelements/</guid>
      <description>Problem Description Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.&#xA;Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] My Idea My initial idea was to store the elements and their respective frequencies in a dictionary, whose keys i sort by frequency and return the first k of them.</description>
    </item>
    <item>
      <title>242. Valid Anagram - LeetCode</title>
      <link>http://localhost:1313/posts/242.validanagram/</link>
      <pubDate>Mon, 22 Jul 2024 22:13:16 +0200</pubDate>
      <guid>http://localhost:1313/posts/242.validanagram/</guid>
      <description>Problem Description Given two strings s and t, return true if t is an anagram of s, and false otherwise.&#xA;An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example 1: Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true Example 2: Input: s = rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false My Idea Since anagrams contain the same letters, my initial idea was to just sort the two strings and compare them.</description>
    </item>
    <item>
      <title>217. Contains Duplicate - LeetCode</title>
      <link>http://localhost:1313/posts/217.containsduplicate/</link>
      <pubDate>Mon, 22 Jul 2024 22:12:44 +0200</pubDate>
      <guid>http://localhost:1313/posts/217.containsduplicate/</guid>
      <description>Problem Description Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.&#xA;Example 1: Input: nums = [1,2,3,1] Output: true Example 2: Input: nums = [1,2,3,4] Output: false My Idea My initial idea was to iterate over the array and store key, value pairs for every element and its frequency. In the end i convert the frequencies to a set and add the value 1 to it.</description>
    </item>
    <item>
      <title>1. Two Sum - LeetCode</title>
      <link>http://localhost:1313/posts/1.twosum/</link>
      <pubDate>Mon, 22 Jul 2024 22:11:59 +0200</pubDate>
      <guid>http://localhost:1313/posts/1.twosum/</guid>
      <description>Problem Description Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.&#xA;You may assume that each input would have exactly one solution, and you may not use the same element twice.&#xA;You can return the answer in any order.&#xA;Example: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
  </channel>
</rss>
