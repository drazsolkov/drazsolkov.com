<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Medium on Denis Razsolkov</title>
    <link>http://localhost:1313/tags/medium/</link>
    <description>Recent content in Medium on Denis Razsolkov</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 09 Aug 2024 22:01:42 +0200</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/medium/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>22. Generate Parentheses - LeetCode</title>
      <link>http://localhost:1313/posts/22.generateparentheses/</link>
      <pubDate>Fri, 09 Aug 2024 22:01:42 +0200</pubDate>
      <guid>http://localhost:1313/posts/22.generateparentheses/</guid>
      <description>Problem Description Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&#xA;Example 1: Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2: Input: n=1 Output: [&amp;quot;()&amp;quot;] My Idea The idea here is that as seen in 20. Valid Parentheses for the parentheses to be well-formed, we need the number of opening ones to match the number of closing ones. Since there are different possible combinations for the parentheses, we use recursion and backtracking.</description>
    </item>
    <item>
      <title>36. Valid Sudoku - LeetCode</title>
      <link>http://localhost:1313/posts/36.validsudoku/</link>
      <pubDate>Fri, 26 Jul 2024 11:24:00 +0200</pubDate>
      <guid>http://localhost:1313/posts/36.validsudoku/</guid>
      <description>Problem Description Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&#xA;Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note:&#xA;A Sudoku board (partially filled) could be valid but is not necessarily solvable.</description>
    </item>
    <item>
      <title>49. Group Anagrams - LeetCode</title>
      <link>http://localhost:1313/posts/49.groupanagrams/</link>
      <pubDate>Thu, 25 Jul 2024 15:10:27 +0200</pubDate>
      <guid>http://localhost:1313/posts/49.groupanagrams/</guid>
      <description>Problem Description Given an array of strings strs, group the anagrams together. You can return the answer in any order.&#xA;An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example 1: Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2: Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3: Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] My Idea My initial idea was to use the sorting approach from [[242.</description>
    </item>
    <item>
      <title>128. Longest Consecutive Sequence - LeetCode</title>
      <link>http://localhost:1313/posts/128.longestconsecutivesequence/</link>
      <pubDate>Thu, 25 Jul 2024 14:35:20 +0200</pubDate>
      <guid>http://localhost:1313/posts/128.longestconsecutivesequence/</guid>
      <description>Problem Description Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.&#xA;You must write an algorithm that runs in O(n) time.&#xA;Example 1: Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2: Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 My Idea To find the longest sequence in O(n) time, we&amp;rsquo;d need to optimize the data structure for nums by converting in to a set, since set lookup happens ins constant time O(1).</description>
    </item>
    <item>
      <title>238. Product of Array Except Self - LeetCode</title>
      <link>http://localhost:1313/posts/238.productofarrayexceptself/</link>
      <pubDate>Wed, 24 Jul 2024 11:20:28 +0200</pubDate>
      <guid>http://localhost:1313/posts/238.productofarrayexceptself/</guid>
      <description>Problem Description Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].&#xA;The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.&#xA;You must write an algorithm that runs in O(n) time and without using the division operation.&#xA;Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] My Idea My initial idea was to create the results list initiated with 1s.</description>
    </item>
    <item>
      <title>347. Top K Frequent Elements - LeetCode</title>
      <link>http://localhost:1313/posts/347.topkfrequentelements/</link>
      <pubDate>Tue, 23 Jul 2024 13:22:39 +0200</pubDate>
      <guid>http://localhost:1313/posts/347.topkfrequentelements/</guid>
      <description>Problem Description Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.&#xA;Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] My Idea My initial idea was to store the elements and their respective frequencies in a dictionary, whose keys i sort by frequency and return the first k of them.</description>
    </item>
  </channel>
</rss>
