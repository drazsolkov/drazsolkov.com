<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Medium on Denis Razsolkov</title>
    <link>http://localhost:1313/tags/medium/</link>
    <description>Recent content in Medium on Denis Razsolkov</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 13 Mar 2025 12:58:41 +0100</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/medium/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>3.Longest Substring Without Repeating Character - Leet Code</title>
      <link>http://localhost:1313/posts/3.longestsubstringwithoutrepeatingcharacter/</link>
      <pubDate>Thu, 13 Mar 2025 12:58:41 +0100</pubDate>
      <guid>http://localhost:1313/posts/3.longestsubstringwithoutrepeatingcharacter/</guid>
      <description>Problem Description Given a string s, find the length of the longest substring without duplicate characters.&#xA;Example 1: Input: s = &amp;quot;abcabcbb&amp;quot; Output: 3 Example 2: Input: s = &amp;quot;pwwkew&amp;quot; Output: 3 My Idea The idea here is to utilize the Sliding Window approach. In every step we increase the window to the right. If we encounter a character that&amp;rsquo;s already a part of the current substring (window), we shorten from the left until the original instance is just outside of the window.</description>
    </item>
    <item>
      <title>981. Time Based Key-Value Store - LeetCode</title>
      <link>http://localhost:1313/posts/981.timebasedkey-valuestore/</link>
      <pubDate>Wed, 05 Mar 2025 11:44:52 +0100</pubDate>
      <guid>http://localhost:1313/posts/981.timebasedkey-valuestore/</guid>
      <description>Problem Description Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key&amp;rsquo;s value at a certain timestamp.&#xA;Implement the TimeMap class:&#xA;TimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev &amp;lt;= timestamp.</description>
    </item>
    <item>
      <title>33. Search in Rotated Sorted Array - LeetCode</title>
      <link>http://localhost:1313/posts/33.searchrotatedsortedarray/</link>
      <pubDate>Fri, 28 Feb 2025 10:38:41 +0100</pubDate>
      <guid>http://localhost:1313/posts/33.searchrotatedsortedarray/</guid>
      <description>Problem Description There is an integer array nums sorted in ascending order (with distinct values).&#xA;Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].&#xA;Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description>
    </item>
    <item>
      <title>153. Finding Minimum in Rotated Sorted Array - LeetCode</title>
      <link>http://localhost:1313/posts/153.findingminimuminrotatedsortedarray/</link>
      <pubDate>Thu, 27 Feb 2025 14:36:46 +0100</pubDate>
      <guid>http://localhost:1313/posts/153.findingminimuminrotatedsortedarray/</guid>
      <description>Problem Description Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:&#xA;[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array numsof unique elements, return the minimum element of this array.</description>
    </item>
    <item>
      <title>875. Koko Eating Bananas - LeetCode</title>
      <link>http://localhost:1313/posts/875.kokoeatingbananas/</link>
      <pubDate>Wed, 26 Feb 2025 15:05:13 +0100</pubDate>
      <guid>http://localhost:1313/posts/875.kokoeatingbananas/</guid>
      <description>Problem Description Koko loves to eat bananas. There are n piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in h hours.&#xA;Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.</description>
    </item>
    <item>
      <title>74. Search a 2D Matrix - LeetCode</title>
      <link>http://localhost:1313/posts/74.search2dmatrix/</link>
      <pubDate>Wed, 26 Feb 2025 13:59:02 +0100</pubDate>
      <guid>http://localhost:1313/posts/74.search2dmatrix/</guid>
      <description>Problem Description You are given an m x n integer matrix matrix with the following two properties:&#xA;Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise.&#xA;You must write a solution in O(log(m * n)) time complexity.&#xA;Example 1: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: True Example 2: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output: False My Idea My idea here was to first utilize binary search on the first element of each row to find the possible row for target and then do one more binary search within this row to check if target is indeed there, thus yielding the desired time complexity of O(log m*n).</description>
    </item>
    <item>
      <title>15. 3Sum - Leet Code</title>
      <link>http://localhost:1313/posts/15.3sum/</link>
      <pubDate>Thu, 17 Oct 2024 14:42:11 +0200</pubDate>
      <guid>http://localhost:1313/posts/15.3sum/</guid>
      <description>Problem Description Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.&#xA;Notice that the solution set must not contain duplicate triplets.&#xA;Example 1: Input: nums = [-1,0,1,2,-1,-4]&#xA;Output: [[-1,-1,2],[-1,0,1]]&#xA;Explanation:&#xA;nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.&#xA;nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</description>
    </item>
    <item>
      <title>11. Container With Most Water - Leet Code</title>
      <link>http://localhost:1313/posts/11.containerwithmostwater/</link>
      <pubDate>Wed, 16 Oct 2024 11:15:06 +0200</pubDate>
      <guid>http://localhost:1313/posts/11.containerwithmostwater/</guid>
      <description>Problem Description You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the i-th line are (i, 0) and (i, height[i]).&#xA;Find two lines that together with the x-axis form a container, such that the container contains the most water.&#xA;Return the maximum amount of water a container can store.&#xA;Notice that you may not slant the container.</description>
    </item>
    <item>
      <title>167. Two Sum II - Input Array is sorted - Leet Code</title>
      <link>http://localhost:1313/posts/167.twosumii/</link>
      <pubDate>Wed, 09 Oct 2024 10:56:02 +0200</pubDate>
      <guid>http://localhost:1313/posts/167.twosumii/</guid>
      <description>Problem Description Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length.&#xA;Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.&#xA;The tests are generated such that there is exactly one solution.</description>
    </item>
    <item>
      <title>853. Car Fleet - Leet Code</title>
      <link>http://localhost:1313/posts/853.carfleet/</link>
      <pubDate>Wed, 02 Oct 2024 14:02:09 +0200</pubDate>
      <guid>http://localhost:1313/posts/853.carfleet/</guid>
      <description>Problem Description There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.&#xA;You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the i-th car and speed[i] is the speed of the i-th car in miles per hour.&#xA;A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.</description>
    </item>
    <item>
      <title>150. Evaluate Reverse Polish Notation - LeetCode</title>
      <link>http://localhost:1313/posts/150.evaluatereversepolishnotation/</link>
      <pubDate>Tue, 01 Oct 2024 10:59:31 +0200</pubDate>
      <guid>http://localhost:1313/posts/150.evaluatereversepolishnotation/</guid>
      <description>Problem Description You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.&#xA;Evaluate the expression. Return an integer that represents the value of the expression.&#xA;Note that:&#xA;The valid operators are &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, and &#39;/&#39;. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation.</description>
    </item>
    <item>
      <title>155. MinStack - LeetCode</title>
      <link>http://localhost:1313/posts/155.minstack/</link>
      <pubDate>Mon, 30 Sep 2024 10:46:12 +0200</pubDate>
      <guid>http://localhost:1313/posts/155.minstack/</guid>
      <description>Problem Description Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.&#xA;Implement the MinStack class:&#xA;MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. You must implement a solution with O(1) time complexity for each function.</description>
    </item>
    <item>
      <title>739. Daily Temperatures - LeetCode</title>
      <link>http://localhost:1313/posts/739.dailytemperatures/</link>
      <pubDate>Sun, 11 Aug 2024 18:42:48 +0200</pubDate>
      <guid>http://localhost:1313/posts/739.dailytemperatures/</guid>
      <description>Problem Description Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.&#xA;Example 1: Input: temperatures = [73,74,75,71,69,72,76,73] Output: [1,1,4,2,1,1,0,0] Example 2: Input: temperatures = [30,40,50,60] Output: [1,1,1,0] My Idea The idea here is to construct a stack of monotonically decreasing values.</description>
    </item>
    <item>
      <title>22. Generate Parentheses - LeetCode</title>
      <link>http://localhost:1313/posts/22.generateparentheses/</link>
      <pubDate>Fri, 09 Aug 2024 22:01:42 +0200</pubDate>
      <guid>http://localhost:1313/posts/22.generateparentheses/</guid>
      <description>Problem Description Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&#xA;Example 1: Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2: Input: n=1 Output: [&amp;quot;()&amp;quot;] My Idea The idea here is that as seen in 20. Valid Parentheses for the parentheses to be well-formed, we need the number of opening ones to match the number of closing ones. Since there are different possible combinations for the parentheses, we use recursion and backtracking.</description>
    </item>
    <item>
      <title>36. Valid Sudoku - LeetCode</title>
      <link>http://localhost:1313/posts/36.validsudoku/</link>
      <pubDate>Fri, 26 Jul 2024 11:24:00 +0200</pubDate>
      <guid>http://localhost:1313/posts/36.validsudoku/</guid>
      <description>Problem Description Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&#xA;Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note:&#xA;A Sudoku board (partially filled) could be valid but is not necessarily solvable.</description>
    </item>
    <item>
      <title>49. Group Anagrams - LeetCode</title>
      <link>http://localhost:1313/posts/49.groupanagrams/</link>
      <pubDate>Thu, 25 Jul 2024 15:10:27 +0200</pubDate>
      <guid>http://localhost:1313/posts/49.groupanagrams/</guid>
      <description>Problem Description Given an array of strings strs, group the anagrams together. You can return the answer in any order.&#xA;An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example 1: Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2: Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3: Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] My Idea My initial idea was to use the sorting approach from [[242.</description>
    </item>
    <item>
      <title>128. Longest Consecutive Sequence - LeetCode</title>
      <link>http://localhost:1313/posts/128.longestconsecutivesequence/</link>
      <pubDate>Thu, 25 Jul 2024 14:35:20 +0200</pubDate>
      <guid>http://localhost:1313/posts/128.longestconsecutivesequence/</guid>
      <description>Problem Description Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.&#xA;You must write an algorithm that runs in O(n) time.&#xA;Example 1: Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2: Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 My Idea To find the longest sequence in O(n) time, we&amp;rsquo;d need to optimize the data structure for nums by converting in to a set, since set lookup happens ins constant time O(1).</description>
    </item>
    <item>
      <title>238. Product of Array Except Self - LeetCode</title>
      <link>http://localhost:1313/posts/238.productofarrayexceptself/</link>
      <pubDate>Wed, 24 Jul 2024 11:20:28 +0200</pubDate>
      <guid>http://localhost:1313/posts/238.productofarrayexceptself/</guid>
      <description>Problem Description Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].&#xA;The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.&#xA;You must write an algorithm that runs in O(n) time and without using the division operation.&#xA;Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] My Idea My initial idea was to create the results list initiated with 1s.</description>
    </item>
    <item>
      <title>347. Top K Frequent Elements - LeetCode</title>
      <link>http://localhost:1313/posts/347.topkfrequentelements/</link>
      <pubDate>Tue, 23 Jul 2024 13:22:39 +0200</pubDate>
      <guid>http://localhost:1313/posts/347.topkfrequentelements/</guid>
      <description>Problem Description Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.&#xA;Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] My Idea My initial idea was to store the elements and their respective frequencies in a dictionary, whose keys i sort by frequency and return the first k of them.</description>
    </item>
  </channel>
</rss>
