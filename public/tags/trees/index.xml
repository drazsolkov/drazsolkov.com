<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Trees on Denis Razsolkov</title>
    <link>http://localhost:1313/tags/trees/</link>
    <description>Recent content in Trees on Denis Razsolkov</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 09 Apr 2025 11:37:21 +0200</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/trees/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>1448. Count Good Nodes In Binary Tree - LeetCode</title>
      <link>http://localhost:1313/posts/1448.countgoodnodesinbinarytree/</link>
      <pubDate>Wed, 09 Apr 2025 11:37:21 +0200</pubDate>
      <guid>http://localhost:1313/posts/1448.countgoodnodesinbinarytree/</guid>
      <description>Problem Description Given a binary tree root, a node X in the tree is named good if in the path from root to X there are no nodes with a value greater than X.&#xA;Return the number of good nodes in the binary tree.&#xA;Example 1: Input: root = [3,1,4,3,null,1,5] Output: 4 Explanation: Nodes in blue are good Example 2: Input: root = [3,3,null,4,2] Output: 3 My Idea The idea here is to utilize a modified pre-order DFS, where at every step we also keep the current max value on the path, so we can make a decision on weather a node is good or not.</description>
    </item>
    <item>
      <title>199. Binary Tree Right Side View - Leet Code</title>
      <link>http://localhost:1313/posts/199.binarytreerightsideview/</link>
      <pubDate>Wed, 09 Apr 2025 11:04:00 +0200</pubDate>
      <guid>http://localhost:1313/posts/199.binarytreerightsideview/</guid>
      <description>Problem Description Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.&#xA;Example 1: Input: root = [1,2,3,null,5,null,4] Output: [1,3,4] Expalantion: Example 2: Input: [1,2,3,4,null,null,null,5] Output: [1,3,4,5] Expalantion: My Idea The trick here is to see that what we need is essentially the rightmost element of every level. This means the last element of every level after a BFS, so we can simply modify the res.</description>
    </item>
    <item>
      <title>102. Binary Tree Level Order Traversal - LeetCode</title>
      <link>http://localhost:1313/posts/102.binarytreelevelordertraversal/</link>
      <pubDate>Wed, 09 Apr 2025 10:54:01 +0200</pubDate>
      <guid>http://localhost:1313/posts/102.binarytreelevelordertraversal/</guid>
      <description>Problem Description Given the root of a binary tree, return the level order traversal of its nodes&amp;rsquo; values. (i.e., from left to right, level by level).&#xA;Example 1: Input: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]] Example 2: Input: root = [] Output: [] My Idea The problem here is essentially implementing Breath First Search (BFS). To do this we need a queue. First we add the root node to the queue. Then while the queue is not empty we create a list for every lvl, which is essentially len(q) at the current iteration.</description>
    </item>
    <item>
      <title>235. Lowest Common Ancestor Of A Binary Search Tree - LeetCode</title>
      <link>http://localhost:1313/posts/235.lowestcommonancestorofabinarysearchtree/</link>
      <pubDate>Wed, 09 Apr 2025 10:26:45 +0200</pubDate>
      <guid>http://localhost:1313/posts/235.lowestcommonancestorofabinarysearchtree/</guid>
      <description>Problem Description Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.&#xA;According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”&#xA;Example 1: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Example 2: Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 My Idea The idea here is to make use of the structure of a Binary Search Tree, namely that for each node the left subtree contains nodes with lower values and the right subtree contains nodes with higher values.</description>
    </item>
    <item>
      <title>572. Subtree Of Another Tree - LeetCode</title>
      <link>http://localhost:1313/posts/572.subtreeofanothertree/</link>
      <pubDate>Fri, 04 Apr 2025 11:58:54 +0200</pubDate>
      <guid>http://localhost:1313/posts/572.subtreeofanothertree/</guid>
      <description>Problem Description Given the roots of two binary trees root and subRoot, return True if there is a subtree of root with the same structure and node values of subRoot and False otherwise.&#xA;A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node&amp;rsquo;s descendants. The tree tree could also be considered as a subtree of itself.&#xA;Example 1: Input: root = [3,4,5,1,2], subRoot = [4,1,2] Output: True Example 2: Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] Output: False My Idea My idea here was to utilize the isSameTree(p,q) function from 100.</description>
    </item>
    <item>
      <title>100. Same Tree - LeetCode</title>
      <link>http://localhost:1313/posts/100.sametree/</link>
      <pubDate>Fri, 04 Apr 2025 10:39:54 +0200</pubDate>
      <guid>http://localhost:1313/posts/100.sametree/</guid>
      <description>Problem Description Given the roots of two binary trees p and q, write a function to check if they are the same or not.&#xA;Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.&#xA;Example 1: Input: p = [1,2,3], q = [1,2,3] Output: True Example 2: Input: p = [1,2], q = [1,null,2] Output: False Example 3: Input: p = [1,2,1], q = [1,1,2] Output: False My Idea My idea here was to modify the algorithm from 104.</description>
    </item>
    <item>
      <title>110. Balanced Binary Tree - LeetCode</title>
      <link>http://localhost:1313/posts/110.balancedbinarytree/</link>
      <pubDate>Thu, 03 Apr 2025 14:58:22 +0200</pubDate>
      <guid>http://localhost:1313/posts/110.balancedbinarytree/</guid>
      <description>Problem Description Given a binary tree, determine if it is height-balanced.&#xA;A height-balanced binary tree is a binary tree in which the depth of the two subtrees of every node never differs by more than one.&#xA;Example 1: Input: root = [3,9,20,null,null,15,7] Output: True Example 2: Input: root = [1,2,2,3,3,null,null,4,4] Output: False Example 3: Input: root = [] Output: True My Idea The idea here is very similar to the one in 543.</description>
    </item>
    <item>
      <title>543. Diameter Of Binary Tree - LeetCode</title>
      <link>http://localhost:1313/posts/543.diameterofbinarytree/</link>
      <pubDate>Thu, 03 Apr 2025 14:33:20 +0200</pubDate>
      <guid>http://localhost:1313/posts/543.diameterofbinarytree/</guid>
      <description>Problem Description Given the root of a binary tree, return the length of the diameter of the tree.&#xA;The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.&#xA;The length of a path between two nodes is represented by the number of edges between them.&#xA;Example 1: Input: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].</description>
    </item>
    <item>
      <title>104. Maximum Depth Of Binary Tree - LeetCode</title>
      <link>http://localhost:1313/posts/104.maximumdepthofbinarytree/</link>
      <pubDate>Thu, 03 Apr 2025 11:18:59 +0200</pubDate>
      <guid>http://localhost:1313/posts/104.maximumdepthofbinarytree/</guid>
      <description>Problem Description Given the root of a binary tree, return its maximum depth.&#xA;A binary tree&amp;rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.&#xA;Example 1: Input: root = [3,9,20,null,null,15,7] Output: 3 Example 2: Input: root = [1,null,2] Output: 2 My Idea My idea here was to utilize recursion and DFS. If the root has no children return 1, else return 1 plus the max from the depths of its children.</description>
    </item>
    <item>
      <title>226. Invert Binary Tree - LeetCode</title>
      <link>http://localhost:1313/posts/226.invertbinarytree/</link>
      <pubDate>Thu, 03 Apr 2025 11:01:35 +0200</pubDate>
      <guid>http://localhost:1313/posts/226.invertbinarytree/</guid>
      <description>Problem Description Given the root of a binary tree, invert the tree, and return its root.&#xA;Example 1: Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] Example 2: Input: root = [2,1,3] Output: [2,3,1] My Idea My idea here was to use recursion and DFS. If the root has no children return root, else swap the left and the right children and invert them.&#xA;My solution from typing import Optional # Definition for a binary tree node.</description>
    </item>
  </channel>
</rss>
