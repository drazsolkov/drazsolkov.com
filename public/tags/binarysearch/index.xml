<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>BinarySearch on Denis Razsolkov</title>
    <link>http://localhost:1313/tags/binarysearch/</link>
    <description>Recent content in BinarySearch on Denis Razsolkov</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 05 Mar 2025 13:40:42 +0100</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/binarysearch/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>4. Median of Two Sorted Arrays - Leet Code</title>
      <link>http://localhost:1313/posts/4.medianoftwosortedarrays/</link>
      <pubDate>Wed, 05 Mar 2025 13:40:42 +0100</pubDate>
      <guid>http://localhost:1313/posts/4.medianoftwosortedarrays/</guid>
      <description>Problem Description Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.&#xA;The overall run time complexity should be O(log (m+n)).&#xA;Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.</description>
    </item>
    <item>
      <title>981. Time Based Key-Value Store - LeetCode</title>
      <link>http://localhost:1313/posts/981.timebasedkey-valuestore/</link>
      <pubDate>Wed, 05 Mar 2025 11:44:52 +0100</pubDate>
      <guid>http://localhost:1313/posts/981.timebasedkey-valuestore/</guid>
      <description>Problem Description Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key&amp;rsquo;s value at a certain timestamp.&#xA;Implement the TimeMap class:&#xA;TimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev &amp;lt;= timestamp.</description>
    </item>
    <item>
      <title>33. Search in Rotated Sorted Array - LeetCode</title>
      <link>http://localhost:1313/posts/33.searchrotatedsortedarray/</link>
      <pubDate>Fri, 28 Feb 2025 10:38:41 +0100</pubDate>
      <guid>http://localhost:1313/posts/33.searchrotatedsortedarray/</guid>
      <description>Problem Description There is an integer array nums sorted in ascending order (with distinct values).&#xA;Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].&#xA;Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description>
    </item>
    <item>
      <title>153. Finding Minimum in Rotated Sorted Array - LeetCode</title>
      <link>http://localhost:1313/posts/153.findingminimuminrotatedsortedarray/</link>
      <pubDate>Thu, 27 Feb 2025 14:36:46 +0100</pubDate>
      <guid>http://localhost:1313/posts/153.findingminimuminrotatedsortedarray/</guid>
      <description>Problem Description Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:&#xA;[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array numsof unique elements, return the minimum element of this array.</description>
    </item>
    <item>
      <title>875. Koko Eating Bananas - LeetCode</title>
      <link>http://localhost:1313/posts/875.kokoeatingbananas/</link>
      <pubDate>Wed, 26 Feb 2025 15:05:13 +0100</pubDate>
      <guid>http://localhost:1313/posts/875.kokoeatingbananas/</guid>
      <description>Problem Description Koko loves to eat bananas. There are n piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in h hours.&#xA;Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.</description>
    </item>
    <item>
      <title>74. Search a 2D Matrix - LeetCode</title>
      <link>http://localhost:1313/posts/74.search2dmatrix/</link>
      <pubDate>Wed, 26 Feb 2025 13:59:02 +0100</pubDate>
      <guid>http://localhost:1313/posts/74.search2dmatrix/</guid>
      <description>Problem Description You are given an m x n integer matrix matrix with the following two properties:&#xA;Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise.&#xA;You must write a solution in O(log(m * n)) time complexity.&#xA;Example 1: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: True Example 2: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output: False My Idea My idea here was to first utilize binary search on the first element of each row to find the possible row for target and then do one more binary search within this row to check if target is indeed there, thus yielding the desired time complexity of O(log m*n).</description>
    </item>
    <item>
      <title>704. Binary Search - LeetCode</title>
      <link>http://localhost:1313/posts/704.binarysearch/</link>
      <pubDate>Tue, 25 Feb 2025 15:18:49 +0100</pubDate>
      <guid>http://localhost:1313/posts/704.binarysearch/</guid>
      <description>Problem Description Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.&#xA;You must write an algorithm with O(log n) runtime complexity.&#xA;Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 My Idea The idea here is to implement the basic version of binary search, where we compare with the middle element and depending on weather it&amp;rsquo;s value is &amp;gt; or &amp;lt; than our target we restrict our problem space to the left or right half of the array respectively.</description>
    </item>
  </channel>
</rss>
