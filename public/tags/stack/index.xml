<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Stack on Denis Razsolkov</title>
    <link>http://localhost:1313/tags/stack/</link>
    <description>Recent content in Stack on Denis Razsolkov</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Fri, 09 Aug 2024 22:01:42 +0200</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/stack/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>22. Generate Parentheses - LeetCode</title>
      <link>http://localhost:1313/posts/22.generateparentheses/</link>
      <pubDate>Fri, 09 Aug 2024 22:01:42 +0200</pubDate>
      <guid>http://localhost:1313/posts/22.generateparentheses/</guid>
      <description>Problem Description Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&#xA;Example 1: Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2: Input: n=1 Output: [&amp;quot;()&amp;quot;] My Idea The idea here is that as seen in 20. Valid Parentheses for the parentheses to be well-formed, we need the number of opening ones to match the number of closing ones. Since there are different possible combinations for the parentheses, we use recursion and backtracking.</description>
    </item>
    <item>
      <title>20. Valid Parentheses - LeetCode</title>
      <link>http://localhost:1313/posts/20.validparentheses/</link>
      <pubDate>Fri, 09 Aug 2024 21:23:04 +0200</pubDate>
      <guid>http://localhost:1313/posts/20.validparentheses/</guid>
      <description>Problem Description Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.&#xA;An input string is valid if:&#xA;Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.&#xA;Example 1: Input: s = &amp;quot;()&amp;quot; Output: True Example 2: Input: s = &amp;quot;()[]{}&amp;quot; Output: True Example 3: Input: s = &amp;quot;(]&amp;quot; Output: False My Idea The idea here is to use a list as a stack, taking advantage of the LIFO strategy.</description>
    </item>
  </channel>
</rss>
