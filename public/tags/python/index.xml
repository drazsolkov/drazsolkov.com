<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on Denis Razsolkov</title>
    <link>http://localhost:1313/tags/python/</link>
    <description>Recent content in Python on Denis Razsolkov</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Thu, 13 Mar 2025 12:58:41 +0100</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>3.Longest Substring Without Repeating Character - Leet Code</title>
      <link>http://localhost:1313/posts/3.longestsubstringwithoutrepeatingcharacter/</link>
      <pubDate>Thu, 13 Mar 2025 12:58:41 +0100</pubDate>
      <guid>http://localhost:1313/posts/3.longestsubstringwithoutrepeatingcharacter/</guid>
      <description>Problem Description Given a string s, find the length of the longest substring without duplicate characters.&#xA;Example 1: Input: s = &amp;quot;abcabcbb&amp;quot; Output: 3 Example 2: Input: s = &amp;quot;pwwkew&amp;quot; Output: 3 My Idea The idea here is to utilize the Sliding Window approach. In every step we increase the window to the right. If we encounter a character that&amp;rsquo;s already a part of the current substring (window), we shorten from the left until the original instance is just outside of the window.</description>
    </item>
    <item>
      <title>121. Best Time to Buy and Sell Stock - LeetCode</title>
      <link>http://localhost:1313/posts/121.besttimetobuyandsellstock/</link>
      <pubDate>Thu, 06 Mar 2025 13:33:46 +0100</pubDate>
      <guid>http://localhost:1313/posts/121.besttimetobuyandsellstock/</guid>
      <description>Problem Description You are given an array prices where prices[i] is the price of a given stock on the i-th` day.&#xA;You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.&#xA;Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.&#xA;Example 1: Input: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.</description>
    </item>
    <item>
      <title>4. Median of Two Sorted Arrays - Leet Code</title>
      <link>http://localhost:1313/posts/4.medianoftwosortedarrays/</link>
      <pubDate>Wed, 05 Mar 2025 13:40:42 +0100</pubDate>
      <guid>http://localhost:1313/posts/4.medianoftwosortedarrays/</guid>
      <description>Problem Description Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.&#xA;The overall run time complexity should be O(log (m+n)).&#xA;Example 1: Input: nums1 = [1,3], nums2 = [2] Output: 2.00000 Explanation: merged array = [1,2,3] and median is 2. Example 2: Input: nums1 = [1,2], nums2 = [3,4] Output: 2.50000 Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.</description>
    </item>
    <item>
      <title>981. Time Based Key-Value Store - LeetCode</title>
      <link>http://localhost:1313/posts/981.timebasedkey-valuestore/</link>
      <pubDate>Wed, 05 Mar 2025 11:44:52 +0100</pubDate>
      <guid>http://localhost:1313/posts/981.timebasedkey-valuestore/</guid>
      <description>Problem Description Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key&amp;rsquo;s value at a certain timestamp.&#xA;Implement the TimeMap class:&#xA;TimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev &amp;lt;= timestamp.</description>
    </item>
    <item>
      <title>33. Search in Rotated Sorted Array - LeetCode</title>
      <link>http://localhost:1313/posts/33.searchrotatedsortedarray/</link>
      <pubDate>Fri, 28 Feb 2025 10:38:41 +0100</pubDate>
      <guid>http://localhost:1313/posts/33.searchrotatedsortedarray/</guid>
      <description>Problem Description There is an integer array nums sorted in ascending order (with distinct values).&#xA;Prior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 &amp;lt;= k &amp;lt; nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].&#xA;Given the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.</description>
    </item>
    <item>
      <title>153. Finding Minimum in Rotated Sorted Array - LeetCode</title>
      <link>http://localhost:1313/posts/153.findingminimuminrotatedsortedarray/</link>
      <pubDate>Thu, 27 Feb 2025 14:36:46 +0100</pubDate>
      <guid>http://localhost:1313/posts/153.findingminimuminrotatedsortedarray/</guid>
      <description>Problem Description Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:&#xA;[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]]. Given the sorted rotated array numsof unique elements, return the minimum element of this array.</description>
    </item>
    <item>
      <title>875. Koko Eating Bananas - LeetCode</title>
      <link>http://localhost:1313/posts/875.kokoeatingbananas/</link>
      <pubDate>Wed, 26 Feb 2025 15:05:13 +0100</pubDate>
      <guid>http://localhost:1313/posts/875.kokoeatingbananas/</guid>
      <description>Problem Description Koko loves to eat bananas. There are n piles of bananas, the i-th pile has piles[i] bananas. The guards have gone and will come back in h hours.&#xA;Koko can decide her bananas-per-hour eating speed of k. Each hour, she chooses some pile of bananas and eats k bananas from that pile. If the pile has less than k bananas, she eats all of them instead and will not eat any more bananas during this hour.</description>
    </item>
    <item>
      <title>74. Search a 2D Matrix - LeetCode</title>
      <link>http://localhost:1313/posts/74.search2dmatrix/</link>
      <pubDate>Wed, 26 Feb 2025 13:59:02 +0100</pubDate>
      <guid>http://localhost:1313/posts/74.search2dmatrix/</guid>
      <description>Problem Description You are given an m x n integer matrix matrix with the following two properties:&#xA;Each row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise.&#xA;You must write a solution in O(log(m * n)) time complexity.&#xA;Example 1: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: True Example 2: Input: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output: False My Idea My idea here was to first utilize binary search on the first element of each row to find the possible row for target and then do one more binary search within this row to check if target is indeed there, thus yielding the desired time complexity of O(log m*n).</description>
    </item>
    <item>
      <title>704. Binary Search - LeetCode</title>
      <link>http://localhost:1313/posts/704.binarysearch/</link>
      <pubDate>Tue, 25 Feb 2025 15:18:49 +0100</pubDate>
      <guid>http://localhost:1313/posts/704.binarysearch/</guid>
      <description>Problem Description Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.&#xA;You must write an algorithm with O(log n) runtime complexity.&#xA;Example 1: Input: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Example 2: Input: nums = [-1,0,3,5,9,12], target = 2 Output: -1 My Idea The idea here is to implement the basic version of binary search, where we compare with the middle element and depending on weather it&amp;rsquo;s value is &amp;gt; or &amp;lt; than our target we restrict our problem space to the left or right half of the array respectively.</description>
    </item>
    <item>
      <title>42. Trapping Rain Water - LeetCode</title>
      <link>http://localhost:1313/posts/42.trappingrainwater/</link>
      <pubDate>Tue, 25 Feb 2025 14:01:44 +0100</pubDate>
      <guid>http://localhost:1313/posts/42.trappingrainwater/</guid>
      <description>Problem Description Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.&#xA;Example 1: Input: height = [0,1,0,2,1,0,1,3,2,1,2,1] Output: 6 My Idea For each position in the resulting figure the amount of water that can be trapped is the minimum of the two highest peaks to the left and right minus the height at the position itself.</description>
    </item>
    <item>
      <title>15. 3Sum - Leet Code</title>
      <link>http://localhost:1313/posts/15.3sum/</link>
      <pubDate>Thu, 17 Oct 2024 14:42:11 +0200</pubDate>
      <guid>http://localhost:1313/posts/15.3sum/</guid>
      <description>Problem Description Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.&#xA;Notice that the solution set must not contain duplicate triplets.&#xA;Example 1: Input: nums = [-1,0,1,2,-1,-4]&#xA;Output: [[-1,-1,2],[-1,0,1]]&#xA;Explanation:&#xA;nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.&#xA;nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.</description>
    </item>
    <item>
      <title>11. Container With Most Water - Leet Code</title>
      <link>http://localhost:1313/posts/11.containerwithmostwater/</link>
      <pubDate>Wed, 16 Oct 2024 11:15:06 +0200</pubDate>
      <guid>http://localhost:1313/posts/11.containerwithmostwater/</guid>
      <description>Problem Description You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the i-th line are (i, 0) and (i, height[i]).&#xA;Find two lines that together with the x-axis form a container, such that the container contains the most water.&#xA;Return the maximum amount of water a container can store.&#xA;Notice that you may not slant the container.</description>
    </item>
    <item>
      <title>167. Two Sum II - Input Array is sorted - Leet Code</title>
      <link>http://localhost:1313/posts/167.twosumii/</link>
      <pubDate>Wed, 09 Oct 2024 10:56:02 +0200</pubDate>
      <guid>http://localhost:1313/posts/167.twosumii/</guid>
      <description>Problem Description Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 &amp;lt;= index1 &amp;lt; index2 &amp;lt;= numbers.length.&#xA;Return the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.&#xA;The tests are generated such that there is exactly one solution.</description>
    </item>
    <item>
      <title>125. Valid Palindrome - Leet Code</title>
      <link>http://localhost:1313/posts/125.validpalindrome/</link>
      <pubDate>Tue, 08 Oct 2024 15:14:48 +0200</pubDate>
      <guid>http://localhost:1313/posts/125.validpalindrome/</guid>
      <description>Problem Description A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.&#xA;Given a string s, return true if it is a palindrome, or false otherwise.&#xA;Example 1: Input: s = &amp;quot;A man, a plan, a canal: Panama&amp;quot; Output: True Explanation: &amp;ldquo;amanaplanacanalpanama&amp;rdquo; is a palindrome. Example 2: Input: s = &amp;quot;race a car&amp;quot; Output: false Explanation: &amp;ldquo;raceacar&amp;rdquo; is not a palindrome.</description>
    </item>
    <item>
      <title>85. Longest Rectangle in Histogram - Leet Code</title>
      <link>http://localhost:1313/posts/85.longestrectangleinhistogram/</link>
      <pubDate>Tue, 08 Oct 2024 11:08:08 +0200</pubDate>
      <guid>http://localhost:1313/posts/85.longestrectangleinhistogram/</guid>
      <description>Problem Description Given an array of integers heights, representing the histogram&amp;rsquo;s bar height, where the width of each bar is 1, return the area of the largest rectangle in the histogram.&#xA;Example 1: Input: heights = [2,1,5,6,2,3] Output: 10 Explanation: The above is a histogram where width of each bar is 1. The largest rectangle is shown in the red area, which has an area = 10 units. Example 2: Input: heights = [2,4] Output: 4 My Idea Here we once more make use of a stack to keep track of the bars.</description>
    </item>
    <item>
      <title>853. Car Fleet - Leet Code</title>
      <link>http://localhost:1313/posts/853.carfleet/</link>
      <pubDate>Wed, 02 Oct 2024 14:02:09 +0200</pubDate>
      <guid>http://localhost:1313/posts/853.carfleet/</guid>
      <description>Problem Description There are n cars at given miles away from the starting mile 0, traveling to reach the mile target.&#xA;You are given two integer array position and speed, both of length n, where position[i] is the starting mile of the i-th car and speed[i] is the speed of the i-th car in miles per hour.&#xA;A car cannot pass another car, but it can catch up and then travel next to it at the speed of the slower car.</description>
    </item>
    <item>
      <title>150. Evaluate Reverse Polish Notation - LeetCode</title>
      <link>http://localhost:1313/posts/150.evaluatereversepolishnotation/</link>
      <pubDate>Tue, 01 Oct 2024 10:59:31 +0200</pubDate>
      <guid>http://localhost:1313/posts/150.evaluatereversepolishnotation/</guid>
      <description>Problem Description You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.&#xA;Evaluate the expression. Return an integer that represents the value of the expression.&#xA;Note that:&#xA;The valid operators are &#39;+&#39;, &#39;-&#39;, &#39;*&#39;, and &#39;/&#39;. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation.</description>
    </item>
    <item>
      <title>155. MinStack - LeetCode</title>
      <link>http://localhost:1313/posts/155.minstack/</link>
      <pubDate>Mon, 30 Sep 2024 10:46:12 +0200</pubDate>
      <guid>http://localhost:1313/posts/155.minstack/</guid>
      <description>Problem Description Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.&#xA;Implement the MinStack class:&#xA;MinStack() initializes the stack object. void push(int val) pushes the element val onto the stack. void pop() removes the element on the top of the stack. int top() gets the top element of the stack. int getMin() retrieves the minimum element in the stack. You must implement a solution with O(1) time complexity for each function.</description>
    </item>
    <item>
      <title>739. Daily Temperatures - LeetCode</title>
      <link>http://localhost:1313/posts/739.dailytemperatures/</link>
      <pubDate>Sun, 11 Aug 2024 18:42:48 +0200</pubDate>
      <guid>http://localhost:1313/posts/739.dailytemperatures/</guid>
      <description>Problem Description Given an array of integers temperatures represents the daily temperatures, return an array answer such that answer[i] is the number of days you have to wait after the ith day to get a warmer temperature. If there is no future day for which this is possible, keep answer[i] == 0 instead.&#xA;Example 1: Input: temperatures = [73,74,75,71,69,72,76,73] Output: [1,1,4,2,1,1,0,0] Example 2: Input: temperatures = [30,40,50,60] Output: [1,1,1,0] My Idea The idea here is to construct a stack of monotonically decreasing values.</description>
    </item>
    <item>
      <title>22. Generate Parentheses - LeetCode</title>
      <link>http://localhost:1313/posts/22.generateparentheses/</link>
      <pubDate>Fri, 09 Aug 2024 22:01:42 +0200</pubDate>
      <guid>http://localhost:1313/posts/22.generateparentheses/</guid>
      <description>Problem Description Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.&#xA;Example 1: Input: n = 3 Output: [&amp;quot;((()))&amp;quot;,&amp;quot;(()())&amp;quot;,&amp;quot;(())()&amp;quot;,&amp;quot;()(())&amp;quot;,&amp;quot;()()()&amp;quot;] Example 2: Input: n=1 Output: [&amp;quot;()&amp;quot;] My Idea The idea here is that as seen in 20. Valid Parentheses for the parentheses to be well-formed, we need the number of opening ones to match the number of closing ones. Since there are different possible combinations for the parentheses, we use recursion and backtracking.</description>
    </item>
    <item>
      <title>20. Valid Parentheses - LeetCode</title>
      <link>http://localhost:1313/posts/20.validparentheses/</link>
      <pubDate>Fri, 09 Aug 2024 21:23:04 +0200</pubDate>
      <guid>http://localhost:1313/posts/20.validparentheses/</guid>
      <description>Problem Description Given a string s containing just the characters &#39;(&#39;, &#39;)&#39;, &#39;{&#39;, &#39;}&#39;, &#39;[&#39; and &#39;]&#39;, determine if the input string is valid.&#xA;An input string is valid if:&#xA;Open brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.&#xA;Example 1: Input: s = &amp;quot;()&amp;quot; Output: True Example 2: Input: s = &amp;quot;()[]{}&amp;quot; Output: True Example 3: Input: s = &amp;quot;(]&amp;quot; Output: False My Idea The idea here is to use a list as a stack, taking advantage of the LIFO strategy.</description>
    </item>
    <item>
      <title>36. Valid Sudoku - LeetCode</title>
      <link>http://localhost:1313/posts/36.validsudoku/</link>
      <pubDate>Fri, 26 Jul 2024 11:24:00 +0200</pubDate>
      <guid>http://localhost:1313/posts/36.validsudoku/</guid>
      <description>Problem Description Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:&#xA;Each row must contain the digits 1-9 without repetition. Each column must contain the digits 1-9 without repetition. Each of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition. Note:&#xA;A Sudoku board (partially filled) could be valid but is not necessarily solvable.</description>
    </item>
    <item>
      <title>49. Group Anagrams - LeetCode</title>
      <link>http://localhost:1313/posts/49.groupanagrams/</link>
      <pubDate>Thu, 25 Jul 2024 15:10:27 +0200</pubDate>
      <guid>http://localhost:1313/posts/49.groupanagrams/</guid>
      <description>Problem Description Given an array of strings strs, group the anagrams together. You can return the answer in any order.&#xA;An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example 1: Input: strs = [&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;,&amp;quot;tan&amp;quot;,&amp;quot;ate&amp;quot;,&amp;quot;nat&amp;quot;,&amp;quot;bat&amp;quot;] Output: [[&amp;quot;bat&amp;quot;],[&amp;quot;nat&amp;quot;,&amp;quot;tan&amp;quot;],[&amp;quot;ate&amp;quot;,&amp;quot;eat&amp;quot;,&amp;quot;tea&amp;quot;]] Example 2: Input: strs = [&amp;quot;&amp;quot;] Output: [[&amp;quot;&amp;quot;]] Example 3: Input: strs = [&amp;quot;a&amp;quot;] Output: [[&amp;quot;a&amp;quot;]] My Idea My initial idea was to use the sorting approach from [[242.</description>
    </item>
    <item>
      <title>128. Longest Consecutive Sequence - LeetCode</title>
      <link>http://localhost:1313/posts/128.longestconsecutivesequence/</link>
      <pubDate>Thu, 25 Jul 2024 14:35:20 +0200</pubDate>
      <guid>http://localhost:1313/posts/128.longestconsecutivesequence/</guid>
      <description>Problem Description Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.&#xA;You must write an algorithm that runs in O(n) time.&#xA;Example 1: Input: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2: Input: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 My Idea To find the longest sequence in O(n) time, we&amp;rsquo;d need to optimize the data structure for nums by converting in to a set, since set lookup happens ins constant time O(1).</description>
    </item>
    <item>
      <title>238. Product of Array Except Self - LeetCode</title>
      <link>http://localhost:1313/posts/238.productofarrayexceptself/</link>
      <pubDate>Wed, 24 Jul 2024 11:20:28 +0200</pubDate>
      <guid>http://localhost:1313/posts/238.productofarrayexceptself/</guid>
      <description>Problem Description Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].&#xA;The product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.&#xA;You must write an algorithm that runs in O(n) time and without using the division operation.&#xA;Example 1: Input: nums = [1,2,3,4] Output: [24,12,8,6] Example 2: Input: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] My Idea My initial idea was to create the results list initiated with 1s.</description>
    </item>
    <item>
      <title>347. Top K Frequent Elements - LeetCode</title>
      <link>http://localhost:1313/posts/347.topkfrequentelements/</link>
      <pubDate>Tue, 23 Jul 2024 13:22:39 +0200</pubDate>
      <guid>http://localhost:1313/posts/347.topkfrequentelements/</guid>
      <description>Problem Description Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.&#xA;Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] My Idea My initial idea was to store the elements and their respective frequencies in a dictionary, whose keys i sort by frequency and return the first k of them.</description>
    </item>
    <item>
      <title>242. Valid Anagram - LeetCode</title>
      <link>http://localhost:1313/posts/242.validanagram/</link>
      <pubDate>Mon, 22 Jul 2024 22:13:16 +0200</pubDate>
      <guid>http://localhost:1313/posts/242.validanagram/</guid>
      <description>Problem Description Given two strings s and t, return true if t is an anagram of s, and false otherwise.&#xA;An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.&#xA;Example 1: Input: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot; Output: true Example 2: Input: s = rat&amp;quot;, t = &amp;quot;car&amp;quot; Output: false My Idea Since anagrams contain the same letters, my initial idea was to just sort the two strings and compare them.</description>
    </item>
    <item>
      <title>217. Contains Duplicate - LeetCode</title>
      <link>http://localhost:1313/posts/217.containsduplicate/</link>
      <pubDate>Mon, 22 Jul 2024 22:12:44 +0200</pubDate>
      <guid>http://localhost:1313/posts/217.containsduplicate/</guid>
      <description>Problem Description Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.&#xA;Example 1: Input: nums = [1,2,3,1] Output: true Example 2: Input: nums = [1,2,3,4] Output: false My Idea My initial idea was to iterate over the array and store key, value pairs for every element and its frequency. In the end i convert the frequencies to a set and add the value 1 to it.</description>
    </item>
    <item>
      <title>1. Two Sum - LeetCode</title>
      <link>http://localhost:1313/posts/1.twosum/</link>
      <pubDate>Mon, 22 Jul 2024 22:11:59 +0200</pubDate>
      <guid>http://localhost:1313/posts/1.twosum/</guid>
      <description>Problem Description Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.&#xA;You may assume that each input would have exactly one solution, and you may not use the same element twice.&#xA;You can return the answer in any order.&#xA;Example: Input: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].</description>
    </item>
  </channel>
</rss>
